# Events, Subscribers and the Render Array

Drupal’s famous for its hook system and it still exists, but some things have been converted over to a new event system, which works exactly the same way; it allows you to create a function and then tell Drupal’s core: when something happens, I want you to call my function.  With hooks, you do that by creating a function with just the right name, so that when something happens in Drupal, it looks to see the function exists and then calls it.  With events, it works a little bit different.  You create the function and then with some configuration you notify Drupal that when something happens, this function should be called.  So it’s the same exact process and system, it’s just set up a slightly different way; and if you can learn how to harness events in Drupal, you’re gonna be very, very dangerous.  

So first thing, click under the profile – and I’m gonna click any icon on the bottom – and one of the tabs that we activated is called Events; and this is awesome because it tells you all of the events and the listeners that have been called on this request.  So first of all, when something happens in Drupal’s core, it’s called an event, an event is dispatched; so that’s kind of like saying a hook is dispatched.  And even every event has a different name, so if you want to hook into one particular thing, you need to know what the name of the event is that happens there.  And when you hear a listener, we’re talking about functions – so like, hook functions.  

So here, you can see that there is an event called kernel.request, which is actually the first event that happens inside of Drupal very early on when the request is being processed.  And over here, there’s some class called Profiler Listener and it has a function called onKernalRequest, so that’s the listener function.  So you can see a bunch of events listeners on kernel.request, there’s another one called kernel.controller, one called render.page_display_variant.select, and then a bunch more after there.  And at the bottom you see Non called listeners – are a bunch of other events that you can hook into.  

Why aren’t they called?  Well, they’re not called because this one, routing.rout_finished, is only called when the route is built, route cache is built.  So if you wanted to hook into the route building process, you could actually attach a listener to this.  By the time you actually go and view a page, this isn’t called because the routing cache has already been built.  And  there’s other ones like config.save, config.delete, etc., etc.  So this is really cool because you can actually go in here and see all of the events that you could actually hook into.  So what I wanna do is hook into an event that happens on every single request right at the very beginning of Symfony, so we’re gonna hook into the kernel.request event and have some code executed before our route or controller is called.  

So in the Jurassic directory – doesn’t really matter where I put it – I’m gonna put a new DinoListener.  And to create an event listener, or really, an event subscriber as they’re called, you’re gonna make this implements EvenSubsciberInterface.  Now, if you’re not comfortable with interfaces yet, go check out or object oriented Episode Three where we talk about interfaces, abstract classes, and more advanced things.  Now I’ll make a command and then ptree [inaudible] [00:03:15], we go to Implement Methods just because that gives me a nice shortcut to basically add all the methods that I need to have when I implement this interface.  

Here, I’ll return an array which says exactly which events I wanna listen to.  And I’m gonna say kernel.request; or actually, instead of saying kernel.request, you can actually say KernalEvents::REQUEST.  That’s just a core Symfony class; notice when I hit tab it added the use statement for me.  KernalEvents::REQUEST just is a constant for kernel.request.  So if that confused you, just use kernel.request, they’re the same thing.  And here, I’ll say onKernalRequest, which is gonna be the name of the method inside this class that I want called; that can be anything, but onKernalRequest is pretty common.  Now, up here, it’s gonna be onKernalRequest, and every event listener, every function that’s called when an event happens is passed an event object.  The tricky thing is that, depending on which event you’re listening to, you’re passed a different event object that gives you different information.  

So once you know which event you want to listen to and you set it up, if you don’t know what event object is passed to you, you can just bar jump it, hit die, and then we can see what event objects are being passed to us.  So this class is set up.  The last thing we need to do is notify Drupal that we have an event listener.  So to do that, you’re gonna do something very familiar, you’re going to register a service.  So you go back into the services key and create a service, and the name of this service doesn’t matter.  We’ll set the class to DinoListener with the full name space.  

And then, for arguments, we can have an arguments key but I’m just going to leave it blank.  So this left score bracket / right score bracket is the single line syntax for arrays.  Now, if I just do this, this is a normal service; it’s not yet an event dispatcher.  We need to somehow tell Drupal, hey, this is not a normal service, this is an event subscriber, so I want you to notice that is has methods in it that subscribe to events.  So whenever you have a service, you want to raise your hand and say, “Ooh, ooh, oh!  Drupal, this is a special service,” you’re gonna use a tag.  And the tag is a bit of a weird syntax in YAML, but it looks like this – so give it a tag, give it the name: event_subscriber.  By doing this, we’ve now told Drupal’s core that our DynoListener service is an event subscriber, and it knows to go in here and figure out what events we subscribed to.  

There are other tags that we use in the system to do other things.  For example, if you want to create a custom Twig plugin, which is called a Twig Extension, and add your own custom functions into Twig, there’s another tag called twig.extension.  So basically, whenever you have a service and you need that service to be hooked into some core system, you’re gonna use a tag to do that.  Now, you don’t need to know much more about this or remember what tags you have, because what’ll happen is you’ll Google “how do I register an event subscriber” and you’ll see that it uses tags.  I just want you to remember that when you give something a tag, it’s your way of making your service special.  All right, let’s go back and rebuild the Drupal cache.  And since the kernel.request of it happens on every single request, we should be able to refresh and then see our die statement hit – and there it is.  
Yep, it’s hitting our die statement and we can say that when you listen to the kernel.request event, you’re passed a GetResponseEvent object.  So now we can go in and type in that: Get ResponseEvent object.  We don’t need to type in, but it’s gonna give us a nice auto-completion.  The event object is really cool because it gives you information about whatever is happening that’s important for that event.  So in this case, you can see that there’s actually a getRequest method on it which’ll give us the request object.  So I’ll set that to request variable.  And the request object is what you’re going to use to get query parameters, post parameters, headers, cookies, the session; anything that deals with requests, we need to always start with request object.  It’s also available in your controller which I haven’t mentioned yet, but this is how you get it in this case.  

What I want to do is, if the URL has a ?roar=1on it, then I want to log a message; if not, I don’t wanna do anything.  So make a new variable called shouldRoar, and to get the query parameters of the request, you say $request->query->get(‘roar’) – and if it’s not there, it will just return null.  And then, down here we’ll just say, if ($shouldRoar) and, for now, I’m just gonna var_dump(ROOOOOOAR’) to see if this is working, and put a die statement.  So we haven’t touched any service configuration, we’ve just touched ptree file; so we can go ahead and refresh.  And it says “Page not found” because we’re on the profiler page, and the profiler’s stored in cache, so it’s not there permanently; so let’s go back to the home page.  Works perfectly and then we add? roar = 1 and enter the die statement – awesome; and this will happen on any page.  

So how can we log this?  Well, this is the same problem that we had earlier when we were working with the roar generator.  In that case, we needed access to the key value factor, so we created a construct function to pass it in; this is no different.  So we need the logger, so we’ll put public function_construct, and I’ll remind you by running drupal container:debug and grep’ing for log.  Then the logger is an instance of LoggerChannelFactory, so we’ll type in LoggerChannelFactory.  And again, you can type into the factory or the interface; I’ll type into the interface, and I’ll hit tab and it adds the use statement for me, and it’ll say loggerFactory.  And then, I’ll just use a quick shortcuts to set that on a property for me, so you could’ve done that manually.  

And then, down here, if you wanna roar, say this>loggerFactory->?get, we’ll use the default channel, and then we’ll do a debug message that says, Roar requested.  ROOOOOOAR.  That should be it.  So again, we didn’t touch any ptree integration files, so we can just refresh.  And if we refresh, we get an error that says our data constructor needs a LoggerChannelFactoryInterface, none given, because we forgot to go back into our services.yml file and actually give it an argument.  So in this case, I’m actually going to leave the argument on a single line, and say logger.factory.  So you notice that arguments can be on two different lines here or you can put them on a single line, and then you would separate them by commas if you had more than one argument; so I wanted to show both because you’ll see both.  So go back, rebuild the cache, refresh, no error this time.  

So let’s head into reports, go into Recent log messages, and there’s our Roar requested.  So this is a listener on kernal request, but you could add a listener to any of the events that the core of Drupal or any third-party modules allow in the system.  And on the topic of listeners, so far we’ve always returned a response object, but now I’m gonna return the RenderArray.  So to return an array, I’ll just put the title, I’ll set that to roar.  So now, let’s go to our URL, the/dino/says/50, and, as expected, we get a full-themed page this time with that set as our title.  And I say “as expected”, but is it expected?  One of the cardinal rules of Symfony controllers is that they must return a Symfony response object; which you’ll notice here, this is not a response object, this is just an array.  So there’s an exception to that rule.  If you don’t return an array, there’s actually a special event that’s called kernel.view.  

So this event here, kernel.view, is only executed if the controller returns something other than a response object.  To return a response object, that’s just used; but if we don’t then kernel.view is called.  And this class down here, the MaincontentViewSubscriber, that’s actually a listener on this event, just like the listener we created, and it is responsible for taking care of the RenderArray; you can see onViewRenderArray.  So if you want to see how the RenderArray system works, you just need to open that class.  And, in fact, I’ll give you a little preview.  If you go into core.services.yml, you’ll see a section in there that includes some services called main_content_renderer, html; main_content_renderer, ajax.  

If you looked into this MainContentViewSubscriber far enough, you’d see it actually uses these classes behind the scenes to figure out how to render the page.  And what’s really interesting is that you see they use a tag here called render, that main_content_renderer, format: html, and render.main_content-renderer, drupal_ajax; and another one down here for drupal_dialog.  So this is totally looking ahead and I’m getting really, really advanced on you guys, but this is the power of the new way of things that are done in Drupal.  If  you wanted to have your own main_content_renderer for some other format, like Json, then all you need to do is create a service, and give it this tag, and pass in your new format.  

So we’ll talk about stuff like that again in the future.  That’s if for now.  If there’s more stuff that you guys wanna know, let me know.  I hope to continue this series based on what you guys are looking for and how things are going in Drupal 8.  So thanks for joining me and hopefully I’ll have more.  But either way, I’ll see you next time.           



